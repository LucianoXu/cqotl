
Extending Quantum Relational Hoare Logics from Optimal Transport Duality with Classic variables and QProver implementation that generates proof obligations resolved by the formalization in the LEAN proof assistant.

% Contributions
% \begin{enumerate}
%     \item A logic with qWhile with classic variables
%     \item Implementation in OCaml to generate proof obligations
%     \item Formalized assertion and resolution of proof obligations in LEAN4
%     \item Examples: 3 to 4
% \end{enumerate}


\section{Type System}
This section introduces the typing system of the prover, which includes the types, terms and propositions.

\newcommand{\qvar}{\textsf{QVar}}
\newcommand{\qreg}[1]{\ensuremath{\textsf{QReg}(#1)}}
\newcommand{\opt}[1]{\ensuremath{\textsf{Opt}(#1)}}
\newcommand{\lopt}{\ensuremath{\textsf{LOpt}}}
\newcommand{\measopt}{\ensuremath{\textsf{MeasOpt}}}
\newcommand{\unitary}[1]{\ensuremath{\textsf{Unitary}({#1})}}
\newcommand{\assn}[1]{\ensuremath{\textsf{Assn}(#1)}}
\newcommand{\meas}[1]{\ensuremath{\textsf{Meas}(#1)}}
\newcommand{\prog}{\ensuremath{\textsf{Prog}}}
\newcommand{\prop}{\ensuremath{\textsf{Prop}}}
\newcommand{\judge}[4]{\ensuremath{\{#1\}~#2 \sim #3~\{#4\}}}

\begin{definition}[type syntax]
    \label{def:type syntax}
    The syntax for types in the prover are defined as follows:
    \begin{align*}
        T ::=\ & \qvar \mid \qreg{n} \mid \opt{n} \mid \lopt \mid \measopt \mid \prog
    \end{align*}
\end{definition}
Here $n$ are positive integers. 

\newcommand{\assert}[1]{\ensuremath{\textsf{assert}(#1)}}
\newcommand{\pf}{\textsf{proof}}

\begin{definition}[term syntax]
    \label{def:term syntax}
    The syntax for terms is defined as follows:
    \begin{align*}
        t ::= x \mid [x_1, x_2, ... x_n] \mid opt \mid lopt \mid \{lopt_1, lopt_2\} \mid stmts
    \end{align*}
\end{definition}
Here $x$ is a variable. $[x_1, x_2, ... x_n]$ is a quantum register. $opt$, $lopt$ and $stmts$ are operators, labeled operators and program statments, which are defined later on. $\{lopt_1, lopt_2\}$ represents the pair of measurement operators.

\begin{definition}[proposition syntax]
    \label{def:prop syntax}
    \begin{align*}
        \phi ::=\ & \unitary{t} \mid \assn{t} \mid \meas{t} \mid \judge{P}{s_1}{s_2}{Q} \\
                & \mid t = t
    \end{align*}
\end{definition}
Here $P$ and $Q$ are operators. $s_1$ and $s_2$ are program terms.

\textbf{Remark:} Here the arguments in constructors like $\judge{P}{s_1}{s_2}{Q}$ are hinted to be particular types, but this is only for elaboration consideration. We adopt the general approach in the implementation, which allows the arguments to be any term in syntax, and validity is guaranteed by type checking.

\subsection{Operators}

\subsection{Program statements}
qwhile programs are encoded as terms in the prover.

\newcommand{\Skip}{\textbf{skip}}
\newcommand{\Init}[1]{\ensuremath{#1:=\ket{0}}}
\newcommand{\If}[3]{\ensuremath{
    \textbf{if}\ #1\ \textbf{then}\ #2\ \textbf{else}\ #3\ \textbf{end}
}}
\newcommand{\While}[2]{\ensuremath{
    \textbf{while}\ #1\ \textbf{do}\ #2\ \textbf{end}
}}

\begin{definition}[program syntax]
    \label{def: prog syntax}
    The program statements are defined as follows:
    \begin{align*}
        & stmts ::= && stmt \mid stmts\ stmt & \text{(statement sequence)} \\
        & stmt ::= && \Skip & \text{(skip)} \\
            & && \mid \Init{t} & \text{(initialization)} \\
            & && \mid U\ t & \text{(unitary transformation)} \\
            & && \mid \If{P}{stmts_1}{stmts_2} & \text{(if statement)} \\
            & && \mid \While{P}{stmts} & \text{(while statement)}
    \end{align*}
\end{definition}


\subsection{Typing}

\newcommand{\WF}[1]{\ensuremath{\mathcal{WF}(#1)}}

We maintain a context $\Gamma$ for the typing of terms and the proof of propositions. 
A context $\Gamma$ consists of a list of declarations, which are definitions $x := t : T$, assumptions $x : T$, proofs $x := \pf : \phi$ or hypothesis $x : \phi$. 
Here \pf\ is a symbol representing the opaque proof of propositions.
We use $[]$ to denote the empty context, and $x \in \Gamma$ to denote that variable $x$ appears in the context as a declaration.
We only work with well-formed contexts, denoted as \WF{\Gamma}. 
The typing judgement, denoted as $\Gamma \vdash t : T$, represents that the term $t$ has type $T$ in well-formed context $\Gamma$. 
The proof judgement, denoted as $\Gamma \vdash \phi$, represents that the proposition is proved in the context.

We use $\Gamma \vdash \phi : \prop$ to denote that $\phi$ is a valid proposition in $\Gamma$. It can be proved using the following rules:
\begin{gather*}
    \frac{\Gamma \vdash o : \opt{n}}{\Gamma \vdash \unitary{o} : \prop}
    \qquad
    \frac{\Gamma \vdash lo : \lopt}{\Gamma \vdash \assn{lo} : \prop} \\
    \\
    \frac{\Gamma \vdash M : \measopt}{\Gamma \vdash \meas{M} : \prop}
    \qquad
    \frac{
        \begin{aligned}
            & \Gamma \vdash \assn{P} \qquad \Gamma \vdash \assn{Q} \\
            & \Gamma \vdash s_1 : \prog \qquad \Gamma \vdash s_2 : \prog
        \end{aligned}}
        {
            \Gamma \vdash \judge{P}{s_1}{s_2}{Q} : \prop
        } \\
    \\
    \frac{\Gamma \vdash o_1 : \opt{n} \qquad \Gamma \vdash o_2 : \opt{n}}{\Gamma \vdash o_1 = o_2 : \prop}
    \qquad
    \frac{\Gamma \vdash lo_1 : \lopt \qquad \Gamma \vdash lo_2 : \lopt}{\Gamma \vdash lo_1 = lo_2 : \prop}
\end{gather*}

The well-formed contexts can be constructed in the following ways:

\begin{gather*}
    \frac{}{\WF{[]}} \\
    \\
    \frac{\WF{\Gamma} \qquad x \notin \Gamma \qquad T \in \{\qvar, \opt{n}, \prog \}}{\WF{\Gamma;x:T}} \\
    \\
    \frac{\WF{\Gamma} \qquad x \notin \Gamma \qquad \Gamma \vdash t : T}{\WF{\Gamma;x := t : T}} \\
    \\
    \frac{\WF{\Gamma} \qquad x \notin \Gamma \qquad \Gamma \vdash \phi : \prop}{\WF{\Gamma;x:\phi}} \\
    \\
    \frac{\WF{\Gamma} \qquad x \notin \Gamma \qquad \Gamma \vdash \phi : \prop \qquad \text{(proof provided)}}{\WF{\Gamma;x:=\pf:\phi}} \\
\end{gather*}

The rules for typing judgements are as follows.

\begin{gather*}
    \frac{\WF{\Gamma} \qquad x : T \in \Gamma}{\Gamma \vdash x : T}
    \qquad
    \frac{\WF{\Gamma} \qquad x := t : T \in \Gamma}{\Gamma \vdash x : T} \\
    \\
    \frac{
        \begin{aligned}
            & \Gamma \vdash q_i : \qvar \text{ for all } i = 1, 2, \dots, n\\
            & q_i \neq q_j \text{ for all } i \neq j
        \end{aligned}}{\Gamma \vdash [q_1, q_2, \dots, q_n] : \qreg{n}} \\
    \\
    \frac{\Gamma \vdash lo_1 : \lopt \qquad \Gamma \vdash lo_2 : \lopt}{\Gamma \vdash \{lo_1, lo_2\} : \measopt}
\end{gather*}

The typing rules for program statements are:
\begin{gather*}
    \frac{\WF{\Gamma}}{\Gamma \vdash \Skip : \prog}
    \qquad
    \frac{\Gamma \vdash t : \qreg{n}}{\Gamma \vdash \Init{t} : \prog} \\
    \\
    \frac{\Gamma \vdash t : \qreg{n} \qquad \Gamma \vdash U : \opt{n} \qquad \Gamma \vdash \unitary{U}}{\Gamma \vdash U\ t : \prog} \\
    \\
    \frac{\Gamma \vdash \meas{M} \qquad \Gamma \vdash s_1 : \prog \qquad \Gamma \vdash s_2 : \prog}
    {\Gamma \vdash \If{M}{s_1}{s_2} : \prog} \\
    \\
    \frac{\Gamma \vdash \meas{M} \qquad \Gamma \vdash s : \prog}
    {\Gamma \vdash \While{M}{s} : \prog}
\end{gather*}

\yx{About unitary and measurement operators: currently we directly assum that all operators involved are valid. We can add the unitary and measurement operator type to further charactorize it.}

The propositions can be proved using the following rules:
\begin{gather*}
    ...
\end{gather*}