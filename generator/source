
Var T : CTYPE.

Var A : OTYPE[T, T].

Var B : OTYPE[T, T].

Check true \/ false /\ false.
Check KTYPE[T].
Var t : CTERM[T].
Var x : CVAR[T].
Check (<t| @ |t>) ^D.


Check fun (x : CTERM[BIT]) => |x>.
Check SUM[USET[BIT], fun (x : CTERM[BIT]) => (<x| @ |x>) ^D].

Prove eqpf : (A + B) + 0O[T] = B + A.
    sorry.
    (* by_lean. *)
    (* Pause. *)
QED.

Var P : ASSN.
Var Q : ASSN.
Var R : ASSN.
Var s1 : PROG.
Var s2 : PROG.

Var M : OPTPAIR[T].
Var qs : QREG[T].
Var b : CVAR[BIT].

Check b := meas M qs. 


Prove pf : {P} skip; ~ skip; {P}.
  r_skip.
QED.

Var H : OTYPE[BIT, BIT].
Var vplus : KTYPE[BIT].


Var P0 : OTYPE[BIT, BIT].
Var P1 : OTYPE[BIT, BIT].

(* The uniform distribution on bit. *)
Var miu : PDIST[BIT].

Prove Pf1 :
    forall (b1 : CVAR[BIT]), 
    forall (b2 : CVAR[BIT]), 
    forall (q : QREG[BIT]),
    {false -> 0O[BIT]_(q,q) | 0O[BIT]_(q,q)} 
        b1 <-$ miu;
            ~ 
        init q; 
        unitary H q; 
        b2 := meas (P0, P1) q; 
    {~(b1 == b2) -> 0O[BIT]_(q,q) | 0O[BIT]_(q,q)}.
    
    intro b1. intro b2. intro q.

    r_seq -2 -2 true -> (|false> @ <false|)_(q,q) | 0O[BIT]_(q,q).

    r_initq.

        simpl_entail. split.
        
        cq_entail. intro H. simpl. dirac. simpl_entail. refl.
        dirac. simpl_entail. refl.

    r_seq -1 1 true -> (vplus @ vplus^D)_(q,q) | 0O[BIT]_(q,q).

    r_unitary. dirac. simpl_entail. split.

        cq_entail. intro H. rewrite H0. simpl. simpl_entail. 
        (* Pause. *)
        by_lean.
        (* Pause. *)
        
        refl.
        (* Pause. *)

    judge_swap.
    r_meas_sample id.

        refl.
    
        split.
            intro H.
            (* A problem here. We don't have types for density operators yet. *)
            dirac. by_lean.
            intro H. dirac. by_lean.
            cq_entail. split.
                simpl. intro H. destruct H0.
                simpl. intro H. destruct H0.
            
            Pause.

QED.

Pause.


Def SWAP := |(true, false)> @ <(false, true)| + |(false, true)> @ <(true, false)|.

Prove Pf2 : 
    forall (x1 : CVAR[BIT]), 
    forall (x2 : CVAR[BIT]), 
    forall (y1 : CVAR[BIT]), 
    forall (y2 : CVAR[BIT]), 
    forall (p1 : QREG[BIT]),
    forall (p2 : QREG[BIT]),
    forall (q1 : QREG[BIT]),
    forall (q2 : QREG[BIT]),
    forall (U : OTYPE[BIT, BIT]),

    {true -> (
        (|(false, false)>@<(false, false)| \/ |(true, true)>@<(true, true)|)_((p1, p2), (p1, p2)) 
        /\ SWAP_((q1, q2), (q1, q2))) | 0O[BIT]_(p1, p1)}

        unitary ((|false> @ <false|) * 1O[BIT] + (|true> @ <true|) * U) (q1, q2);
        x1 := meas (P0, P1) q1;
        y1 := meas (P0, P1) q2;

        ~

        x2 := meas (P0, P1) q1;
        if x2 then 
            unitary U q2;
        else
            skip;
        end;
        y2 := meas (P0, P1) q2;

    {~(x1 == x2 /\ y1 == y2) -> 0O[BIT]_(p1, p1) | 0O[BIT]_(p1, p1)}.

    expand SWAP.
