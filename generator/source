
(* example 1 *)

Var H : OTYPE[BIT, BIT].
Var vplus : KTYPE[BIT].

Var P0 : OTYPE[BIT, BIT].
Var P1 : OTYPE[BIT, BIT].

(* The uniform distribution on bit. *)
Var miu : PDIST[BIT].

Prove Pf1 :
    forall (b1 : CVAR[BIT]), 
    forall (b2 : CVAR[BIT]), 
    forall (q : QREG[BIT]),
    {false -> 0O[BIT]_(q,q) | 0O[BIT]_(q,q)} 
        b1 <-$ miu;
            ~ 
        init q; 
        unitary H q; 
        b2 := meas (P0, P1) q; 
    {~(b1 == b2) -> 0O[BIT]_(q,q) | 0O[BIT]_(q,q)}.
    
    intro b1. intro b2. intro q.

    r_seq -2 -2 true -> (|false> @ <false|)_(q,q) | 0O[BIT]_(q,q).

    r_initq.

        simpl_entail. split.

        cq_entail. intro H. simpl. dirac. simpl_entail. refl.
        dirac. simpl_entail. refl.

    r_seq -1 1 true -> (vplus @ vplus^D)_(q,q) | 0O[BIT]_(q,q).

    r_unitary. dirac. simpl_entail. split.

        cq_entail. intro H. rewrite H0. simpl. simpl_entail.
        by_lean.
        
        refl.

    judge_swap.
    r_meas_sample id.

        refl.
    
        split.
            intro H.
            (* A problem here. We don't have types for density operators yet. *)
            dirac. by_lean.
            intro H. dirac. by_lean.
            cq_entail. split.
                simpl. intro H. destruct H0.
                simpl. intro H. destruct H0.

QED.

(* example 2 *)

Def Psym2 := |(true, false)> @ <(false, true)| + |(false, true)> @ <(true, false)| + |(true, true)> @ <(true, true)| + |(false, false)> @ <(false, false)|.


Prove Lemma1 : forall (x : CTERM[BIT]), ~ ~ x = x.

    intro x. simpl. refl.

QED.

Prove Lemma2 : forall (x : CVAR[BIT]), forall (y : CVAR[BIT]), 
    forall (H : ~ (x == y) = true), (x == y) = false.

    intro x. intro y. intro H.
    rewrite <- Lemma1 @ (x == y).
    rewrite H0. simpl. refl.
QED.

Prove Pf2 : 
    forall (x : CVAR[BIT]), forall (x' : CVAR[BIT]), 
    forall (y : CVAR[BIT]), forall (y' : CVAR[BIT]), 
    forall (q1 : QREG[BIT]), forall (q1' : QREG[BIT]),
    forall (q2 : QREG[BIT]), forall (q2' : QREG[BIT]),
    forall (U : OTYPE[BIT, BIT]),

    {true -> (
        (|(false, false)>@<(false, false)| \/ |(true, true)>@<(true, true)|)_((q1, q1'), (q1, q1')) 
        /\ Psym2_((q2, q2'), (q2, q2'))) | 0O[BIT]_(q1, q1)}

        unitary ((|false> @ <false|) * 1O[BIT] + (|true> @ <true|) * U) (q1, q2);
        x := meas (P0, P1) q1;
        y := meas (P0, P1) q2;

        ~

        x' := meas (P0, P1) q1';
        if x' then 
            unitary U q2';
        else
            skip;
        end;
        y' := meas (P0, P1) q2';

    {~(x == x' /\ y == y') -> 0O[BIT]_(q1, q1) | 0O[BIT]_(q1, q1)}.


    intro x. intro x'. intro y. intro y'.
    intro q1. intro q1'. intro q2. intro q2'. intro U.
    expand Psym2.
    r_seq -1 -1 (~(x == x') -> 0O[BIT]_(q1, q1) /\ ((x == x') -> Psym2_((q2, q2'), (q2, q2')))) | 0O[BIT]_(q1, q1).

    choose 2. expand Psym2.
    
    r_meas_meas id.

    simpl. refl.

    split. split. 
        intro H. 
        rewrite Lemma2 @ x @ x' @ H0.
        dirac. simpl. dirac.
        (* this obligation involves quantum coupling and it's not sure how to deal with it for now *)
        by_lean.

    
        intro H. 
        rewrite Lemma2 @ x @ x' @ H0.
        dirac. simpl. dirac.
        (* same as before *)
        by_lean.
        

        split.
        intro H.
        rewrite H0. simpl. dirac.
        (* same as before *)
        by_lean.

        (* same as before *)
        by_lean.

    r_seq 2 -1 (~(x == x') -> 0O[BIT]_(q1, q1) 
                /\ ((x == false /\ x' == false) -> Psym2_((q2, q2'), (q2, q2'))) 
                /\ ((x == true /\ x' == true) -> U_(q2, q2) @ Psym2_((q2, q2'), (q2, q2')) @ U^D_(q2, q2))) | 0O[BIT]_(q1, q1).

    choose 2.

    r_if q1.

        sorry.

        r_skip.
        (* Pause. *)
          simpl_entail. 
          split. cq_entail. split.
            (* *)
            intro H. rewrite H0. simpl.

            rwrule 0O[BIT, BIT]_(q1, q1) /\ A --> 0O[BIT, BIT]_(q1, q1).
            rwrule 0O[BIT, BIT]_(q1, q1) /\ A --> 0O[BIT, BIT]_(q1, q1).
            rwrule A /\ 0O[BIT, BIT]_(q1, q1) --> 0O[BIT, BIT]_(q1, q1).
            simpl_entail. refl.

            (* *)
            intro H. rewrite H0. simpl.
            rwrule 1O[BIT]_(q1, q1) /\ A --> A.
            
            (* problem: need to use a lemma of <= *)
            by_lean.
        
            refl.

    r_seq 1 0 true -> 
        ((|(false, false)> @ <(false, false)|)_((q1, q1'), (q1, q1')) /\ Psym2_((q2, q2'), (q2, q2')) 
        \/ (|(true, true)> @ <(true, true)|)_((q1, q1'), (q1, q1')) /\ U_(q2, q2) @ Psym2_((q2, q2'), (q2, q2')) @ U^D_(q2, q2)) | 0O[BIT]_(q1, q1).

    r_unitary.
    dirac. simpl_entail. split. simpl.

    (* crazy obligation that requires adjusting labels *)
    by_lean.

    (* *)
    rwrule A @ 0O[BIT, BIT]_(q1, q1) --> 0O[BIT, BIT]_(q1, q1).

    rwrule 0O[BIT, BIT]_(q1, q1) @ A --> 0O[BIT, BIT]_(q1, q1).

    simpl_entail. refl.

    r_meas_meas id. refl.

    simpl. split.
        (* *)
        intro H.
        (* crazy obligation *)
        by_lean.

        (* *)
        intro H.
        (* crazy obligation *)
        by_lean.

    (* Pause. *)
QED.


(* example 3*)

Var CX : OTYPE[BIT * BIT, BIT * BIT].
Var sADD : forall (x : CTERM[BIT]), forall (y : CTERM[BIT]), CTERM[BIT].
Var sSUB : forall (x : CTERM[BIT]), forall (y : CTERM[BIT]), CTERM[BIT].

Def Psym4 := |((true, true), (true, true))> @ <((true, true), (true, true))| + 
            |((true, true), (true, false))> @ <((true, false), (true, true))| +
            |((true, true), (false, true))> @ <((false, true), (true, true))| +
            |((true, true), (false, false))> @ <((false, false), (true, true))| +

            |((true, false), (true, true))> @ <((true, true), (true, false))| +
            |((true, false), (true, false))> @ <((true, false), (true, false))| +
            |((true, false), (false, true))> @ <((false, true), (true, false))| +
            |((true, false), (false, false))> @ <((false, false), (true, false))| +

            |((false, true), (true, true))> @ <((true, true), (false, true))| +
            |((false, true), (true, false))> @ <((true, false), (false, true))| +
            |((false, true), (false, true))> @ <((false, true), (false, true))| +
            |((false, true), (false, false))> @ <((false, false), (false, true))| +

            |((false, false), (true, true))> @ <((true, true), (false, false))| +
            |((false, false), (true, false))> @ <((true, false), (false, false))| +
            |((false, false), (false, true))> @ <((false, true), (false, false))| +
            |((false, false), (false, false))> @ <((false, false), (false, false))|.


Prove Pf3 :
    forall (x : CVAR[BIT]), forall (x' : CVAR[BIT]), 
    forall (y : CVAR[BIT]), forall (y' : CVAR[BIT]), 
    forall (a : CVAR[BIT]), forall (a' : CVAR[BIT]), 
    forall (b : CVAR[BIT]), forall (b' : CVAR[BIT]), 
    forall (r : CVAR[BIT]), forall (r' : CVAR[BIT]), 
    forall (q1 : QREG[BIT]), forall (q1' : QREG[BIT]),
    forall (q2 : QREG[BIT]), forall (q2' : QREG[BIT]),
    forall (U : OTYPE[BIT * BIT, BIT * BIT]),
    forall (U' : OTYPE[BIT, BIT]),

    { true -> Psym4_(((q1, q2), (q1', q2')), ((q1, q2), (q1', q2'))) | 0O[BIT]_(q1, q1)}

        unitary U (q1, q2);
        unitary CX (q2, q1);
        y := meas (P0, P1) q1;
        if y then 
            unitary U' q2;
        else
            skip;
        end;

        a := sADD @ x @ y;
        b := sSUB @ y @ x;
        r := sADD @ a @ b;

        ~

        unitary U (q1', q2');
        x' := meas (P0, P1) q1';
        y' := meas (P0, P1) q2';
        a' := sADD @ x' @ y';
        b' := sSUB @ y' @ x';
        r' := sADD @ a' @ b';

    {~(r == r') -> 0O[BIT]_(q1, q1) | 0O[BIT]_(q1, q1)}.



    sorry.


QED.

(* example 4 *)

Var X : OTYPE[BIT, BIT].

Prove Pf4 :
    forall (x : CVAR[BIT]),
    forall (q : QREG[BIT]), forall (q' : QREG[BIT]),

    { false -> 0O[BIT]_(q, q) | 0O[BIT]_(q, q)}
        init q;
        x := false;
        while ~ x do 
            unitary H q;
            x := meas (P0, P1) q;
        end;

        ~
        init q';
        unitary X q;
    {true -> Psym2_((q, q'), (q, q')) | 0O[BIT]_(q, q)}.

    Pause.
    sorry.

QED.

          